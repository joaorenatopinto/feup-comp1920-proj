options
{
    LOOKAHEAD=2;
}

PARSER_BEGIN(Compiler)

import java.util.*;

public class Compiler
{
    public static HashMap<String, Integer> symbol_table = new HashMap<String, Integer>();

    public static void main(String args[]) throws ParseException {
        System.out.println("Parser for Mini Java grammar");
        System.out.println("Write your shitty code:");
        Compiler comp = new Compiler(System.in);
        SimpleNode root = comp.Program(); // returns reference to root node

        root.dump(""); // prints the tree on the screen

        //System.out.println("Expression value: "+myCalc.eval(root));
    }
    /*
    int eval(SimpleNode node) {
        if(node.id == CalculatorTreeConstants.JJTNEG) {
            return -1 * eval((SimpleNode) node.jjtGetChild(0));
        }
        else if(node.jjtGetNumChildren() == 0) // leaf node with integer value
            return node.val;
        else if(node.jjtGetNumChildren() == 1) {// only one child
            return this.eval((SimpleNode) node.jjtGetChild(0));
        }

        SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child
        SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child

        switch(node.id) {
            case CalculatorTreeConstants.JJTADD : return eval( lhs ) + eval( rhs );
            case CalculatorTreeConstants.JJTSUB: return eval( lhs ) - eval( rhs );
            case CalculatorTreeConstants.JJTMUL : return eval( lhs ) * eval( rhs );
            case CalculatorTreeConstants.JJTDIV : return eval( lhs ) / eval( rhs );
            default : // abort
                System.out.println("Ilegal operator!");
                System.exit(1);
        }
        return 0;
    }*/
}



PARSER_END(Compiler)

SKIP :
{
    " " | "\r" | "\t" | "\n"
    | < "//" (~["\r", "\n"])* >
    | < "/*" > : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP :
{
  < "*/" > : DEFAULT
| < ~[] >   
}

TOKEN:
{
    < INTEGER: (["0"-"9"])+ >
    | < IF: "if" >
    | < INT: "int" >
    | < NEW: "new" >
    | < VOID: "void" >
    | < ELSE: "else" >
    | < TRUE: "true" >
    | < MAIN: "main" >
    | < THIS: "this" >
    | < WHILE: "while" >
    | < FALSE: "false" >
    | < CLASS: "class" >
    | < PUBLIC: "public" >
    | < STATIC: "static" >
    | < STRING: "String" >
    | < LENGTH: "length" >
    | < RETURN: "return" >
    | < BOOLEAN: "boolean" >
    | < EXTENDS: "extends" >
    | < IMPORT: "import" >
    | < IDENTIFIER: ( (["$"]|["_"]|["A"-"Z"]|["a"-"z"])(["0"-"9"]|["A"-"Z"]|["a"-"z"]|["_"])*) >
    
}

SimpleNode Program(): {}
{
    Start() { return jjtThis;}
}

void Start() : {}
{
    Imports() ClassDeclaration() <EOF> #File(2)
}

void Imports() : {}
{
    ( ImportDeclaration() )*
}

void ImportDeclaration() : {}
{
    "import" ["static"] <IDENTIFIER> [ "." <IDENTIFIER> "(" [ ( Type() | "void" ) ( "," ( Type() | "void" )  )* ] ")" [ Type() | "void" ] ] ";" 
}

void ClassDeclaration() : {}
{
    "class" <IDENTIFIER> [ "extends" <IDENTIFIER> ] "{" ( VarDeclaration() )* ( MethodDeclaration() )* "}"
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> ";"
}

void MethodDeclaration() : {}
{
    "public" Type() <IDENTIFIER> "(" [ Type() <IDENTIFIER> ( "," Type() <IDENTIFIER> )* ] ")" "{" ( VarDeclaration() )* ( Statement() )* "return" Expression() ";" "}"
    | "public" "static" "void" "main" "("  "String" "[" "]" <IDENTIFIER> ")" "{" ( VarDeclaration() )* ( Statement() )* "}"
}

void Type() #void: {}
{
    "int" "[" "]"
    | "boolean"
    | "int"
    | <IDENTIFIER>
}

void Statement() : {}
{
    "{" ( Statement() )* "}"
    | "if" "(" Expression() ")" Statement() #If(2) "else" Statement() #Else(1)
    | "while" "("Expression() ")" Statement() #While(2)
    | <IDENTIFIER> "[" Expression() "]" #Identifier(1) "=" Expression() ";" #Assign(2)
    | <IDENTIFIER> #Identifier "=" Expression() ";" #Assign(2)
    | Expression() ";"  
}

void Expression() #void : {}
{
    <INTEGER> #Int [Express() #GroupCondition(2)]
    | "true" #True [Express() #GroupCondition(2)]
    | "false" #False [Express() #GroupCondition(2)]
    | <IDENTIFIER> #Identifier [Express() #GroupCondition(2)]
    | "this" #This [Express() #GroupCondition(2)]
    | "new" "int" "[" Expression() "]" #Array(1) [Express() #GroupCondition(2)]
    | "new" <IDENTIFIER> "(" ")" #Object [Express() #GroupCondition(2)]
    | "!" Expression() #Neg(1) [Express() #GroupCondition(2)]
    | "(" Expression() ")" #Group(1) [Express() #GroupCondition(2)]
}

void Express() #void : {}
{
    ( "&&" Expression() #And(1) | "<" Expression() #Less(1) | "+" Expression() #Plus(1) | 
    "-" Expression() #Minus(1)  | "*" Expression() #Mult(1) | "/" Expression() #Div(1) ) [Express()]
    | "[" Expression() "]" #AcessArray(1) [Express() #GroupCondition(2)]
    | "." "length" #Length [Express() #GroupCondition(2)]
    | AcessMethod() [Express() #GroupCondition(2)]
}

void AcessMethod() : {}
{
    "." <IDENTIFIER> "(" [ Arguments() ] ")"
}



void Arguments() : {}
{
    Expression() ("," Expression())*
}