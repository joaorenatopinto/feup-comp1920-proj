options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Compiler)

import java.util.*;
import java.io.*;

public class Compiler
{
    static int nErrors;
    static int MAX_ERRORS = 10;

    public static HashMap<String, Integer> symbol_table = new HashMap<String, Integer>();

    public static void main(String args[]) throws ParseException, IOException {
        nErrors = 0;
        System.out.println("Parser for Mini Java grammar");
        System.out.println("Your shitty code's AST:");
        System.setIn(new FileInputStream(new File(args[0])));
        Compiler comp = new Compiler(System.in);
        SimpleNode root = comp.Program(); // returns reference to root node

        root.dump(""); // prints the tree on the screen
    }

    static void reportError(ParseException e, String statement, boolean recover) {
        System.out.println("Syntatic error on " + statement + " statement.\n\n" +  e.toString());
        nErrors++;
      
        if (recover) {
          recoverFromError();
        }
      
        if (nErrors >= MAX_ERRORS) {
          System.out.println("Reached maximum number of errors (" + MAX_ERRORS + "). Terminating.");
          System.exit(1);
        }
      }
    
    static void recoverFromError() {
        Token t;
        Token t2;
        // do {
        //     // t = getToken(1);
        //     // if (t.kind == RPARENTHESIS) {
        //     //     t2 = getToken(1);
        //     //     if (t2.kind == LBRACKET | t2.kind == SEMICOLON) {
        //     //         return;
        //     //     }
        //     // }
        //     // t = getNextToken();

        //     t = getToken(1);
        //     if (t.kind == RPARENTHESIS)
        //         break;
                
        //     System.out.print(t.kind + " ");
        //     t = getNextToken();
        // } while (t.kind != RPARENTHESIS);
        // t = getNextToken();

        t = getToken(1);

        do {

            do {

                System.out.print(t.kind + " ");

                t2 = getToken(1);

                if (t2.kind == LBRACKET)
                    return;
                
                if (t.kind == RPARENTHESIS)
                    break;
                    
                t = getNextToken();

            } while (t.kind != RPARENTHESIS );

            t = getToken(1);

            if (t.kind == RPARENTHESIS)
                t = getNextToken();

        } while (t.kind == RPARENTHESIS);

////////////////////////
        // do {
        //     t = getNextToken();

        // } while (t.kind != SEMICOLON && t != null && t.kind != EOF);
    }
    
}



PARSER_END(Compiler)

SKIP :
{
    " " | "\r" | "\t" | "\n"
    | < "//" (~["\r", "\n"])* >
    | < "/*" > : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP :
{
  < "*/" > : DEFAULT
| < ~[] >   
}

TOKEN:
{
    < INTEGER: (["0"-"9"])+ >
    | < SEMICOLON: ";" >
    | < IF: "if" >
    | < INT: "int" >
    | < NEW: "new" >
    | < VOID: "void" >
    | < ELSE: "else" >
    | < TRUE: "true" >
    | < MAIN: "main" >
    | < THIS: "this" >
    | < WHILE: "while" >
    | < FALSE: "false" >
    | < CLASS: "class" >
    | < PUBLIC: "public" >
    | < STATIC: "static" >
    | < STRING: "String" >
    | < LENGTH: "length" >
    | < RETURN: "return" >
    | < BOOLEAN: "boolean" >
    | < EXTENDS: "extends" >
    | < IMPORT: "import" >
    | <LPARENTHESIS: "(" >
    | <RPARENTHESIS: ")" >
    | <LBRACKET: "{" >
    | <RBRACKET: "}" >
    | < IDENTIFIER: ( (["$"]|["_"]|["A"-"Z"]|["a"-"z"])(["$"]|["0"-"9"]|["A"-"Z"]|["a"-"z"]|["_"])*) >
    
}

SimpleNode Program(): {}
{
    Start() { return jjtThis;}
}

void Start() : {}
{
    Imports() ClassDeclaration() <EOF> #File(2)
}

void Imports() : {}
{
    ( ImportDeclaration() )*
}

void ImportDeclaration() : {}
{
    "import" ["static"] <IDENTIFIER> [ "." <IDENTIFIER> "(" [ ( Type() | "void" ) ( "," ( Type() | "void" )  )* ] ")" [ Type() | "void" ] ] ";" 
}

void ClassDeclaration() : {/* Token t1; Token t2; */}
{
    "class" /* t1 =*/<IDENTIFIER> [ "extends" /* t2= */<IDENTIFIER> ] "{" ( VarDeclaration() )* ( MethodDeclaration() )* "}" {/* jjtThis.id = t1.image; jjtThis.ext = t2.image; */}
}

void VarDeclaration() : {/* Token t1; */}
{
    Type() /* t1= */<IDENTIFIER> ";" {/* jjtThis.id = t1.image; */}
}

void MethodDeclaration() : {/* Token t1; */}
{  
    "public"  
    (
    Type() /* t1= */<IDENTIFIER> "(" [ MethodArgs() ] ")" "{" ( LOOKAHEAD(2) VarDeclaration() )* ( Statement() )* "return" Cal1() ";" "}" {/* jjtThis.id = t1.image; */}
    | "static" "void" "main" "("  "String" "[" "]" <IDENTIFIER> ")" "{" ( LOOKAHEAD(2) VarDeclaration() )* ( Statement() )* "}" 
    ) 
}

void MethodArgs() : {}
{
    Type() <IDENTIFIER> ( "," Type() <IDENTIFIER> )*
}

void Type() #void: {}
{  
    "boolean"
    | "int" ["[" "]"]
    | <IDENTIFIER>
}

void Statement() : {}
{
    "{" ( Statement() )* "}"
    | "if" "(" Cal1() ")" Statement() #If(2) "else" Statement() #Else(1)
    | WhileStatement()        
    | LOOKAHEAD(2) <IDENTIFIER> "[" Cal1() "]" #Identifier(1) "=" Cal1() ";" #Assign(2)
    | LOOKAHEAD(2) <IDENTIFIER> #Identifier "=" Cal1() ";" #Assign(2)
    | Cal1() ";"  
}

void WhileStatement() : {} {
    <WHILE> <LPARENTHESIS> 
    try {
        Cal1() <RPARENTHESIS>
     } catch (ParseException e) {
       reportError(e, "WHILE", true);
     }
     Statement()
}

void Cal1() #void: {} { 
    Cal2()
    (
        LOOKAHEAD(2) "&&" Cal2() #And(2)
    )*
}
 
void Cal2() #void: {} { 
    Cal3()
    (
        LOOKAHEAD(2) "<" Cal3() #Less(2)
    )*
}


void Cal3() #void: {} {
    Cal4() 
    (
        LOOKAHEAD(2) ( 
            "+" Cal4() #Add(2)
            | "-" Cal4() #Sub(2)
        )
    )*
}

void Cal4() #void: {} {
    Cal5()
    (
        LOOKAHEAD(2) ( 
            "*" Cal5() #Mul(2)
            | "/" Cal5() #Div(2) 
        )
    )*
}


void Cal5() #void: {} {
    "(" Cal1() ")"
    | Expression1()
}


void Expression1() #void : {}
{
    <INTEGER> #Int [LOOKAHEAD(2) Express1() #GroupCondition(2)]
    | "true" #True [LOOKAHEAD(2) Express1() #GroupCondition(2)]
    | "false" #False [LOOKAHEAD(2) Express1() #GroupCondition(2)]
    | <IDENTIFIER> #Identifier [LOOKAHEAD(2) Express1() #GroupCondition(2)]
    | "this" #This [LOOKAHEAD(2) Express1() #GroupCondition(2)]
    | "new" (
        "int" "[" Cal1() "]" #Array(1) [LOOKAHEAD(2) Express1() #GroupCondition(2)]
        | <IDENTIFIER> "(" ")" #Object [LOOKAHEAD(2) Express1() #GroupCondition(2)]
    )
    | "!" Cal1() #Neg(1) [LOOKAHEAD(2) Express1() #GroupCondition(2)]
}


void Express1() #void : {}
{ 
    "[" Cal1() "]" #AcessArray(1) [LOOKAHEAD(2) Express1() #GroupCondition(2)]
    | "." (
        "length" #Length [LOOKAHEAD(2) Express1() #GroupCondition(2)]
        | AcessMethod() [LOOKAHEAD(2) Express1() #GroupCondition(2)]
    )
}


void AcessMethod() : {}
{
    <IDENTIFIER> "(" [ Arguments() ] ")"
}


void Arguments() : {}
{
    Cal1() ("," Cal1())*
}
