NOVO:

 - STACK:
    ////////////////////////////////////////////////////////////////////////
        Lógica principal do controlo da stack por método:
        maxStack = 0;
        totalStacK = 0;
        void incStack(){
            totalStack++;
            if(totalStack > maxStack){
                maxStack = totalStack;
            }
        }
        void decStack(int value){
            totalStack-= value;
        }
        ////////////////////////////////////////////////////////////////////////
        1. for each Statement in the code invoke the inc or dec methods according to the instructions you will use.
        for instance: for iload_0 you will do a incStack(), if it is a istore_0 you will do a decStack(1)
        2. guarantee that at the end of the statement the stack is empty! E.g. if you invoke a method that returns something as a single statement (e.g. this.incMyVar(); and assuming the method returns an integer) then you have to do a pop of that value (literally the "pop" instruction"). Something like this:
        while(totalStack !== 0){
        pop();
        totalStacK--;
        }
        3. no final do método podemos calcular o que queremos:
        ".limit stack " + maxStack
        ".limit locals " + (isStatic?0:1 + params.length + localVars.length)
        "<the rest of the code>"
        ////////////////////////////////////////////////////////////////////////
        exemplo por statement para o código seguinte:
        class Simple{
            public void test(int a, int b){
        1.        a = b + 10 * (3 + this.add(3,4));
        2.        this.add(3,4);
            }
        }
        ----------------1.--------------------------
        iload_2    ==> incStack                  | 1
        bipush 10  ==> incStack                  | 2
        iconst_3   ==> incStack                  | 3
        aload 0    ==> incStack                  | 4
        iconst_3   ==> incStack                  | 5
        iconst 4   ==> incStack                  | 6
        invokedynamic ....(II)I  => decStack(3-1)| 4 // why 3-1? objectref+numargs-return (if not returning void)
        iadd       ==> decStack(1)               | 3       
        imul       ==> decStack(1)               | 2
        iadd       ==> decStack(1)               | 1
        istore 1   ==> decStack(1)               | 0
        -----------------2.--------------------------
        aload 0    ==> incStack                  | 1
        iconst_3   ==> incStack                  | 2
        iconst 4   ==> incStack                  | 3
        invokedynamic ....(II)I  => decStack(3-1)| 1
        pop                      => decStack(1)  | 0
            
 - IMPORTS
 - FUNCOES (FALTA CLASSE A QUE PERTENCE)

ABRAÇO


PRINTS:

getstatic java/lang/System.out Ljava/io/PrintStream;
iload 1 
invokevirtual java/io/PrintStream.println(I)V


The final submission is almost here and we want to explain a little bit what we want for this final version. Keep in mind that this is just a helper for the real project description! There are some info in the description that it is not mentioned here (e.g. command line format)
1 First of all this is the final checklist:
1.1. Have all the previous checkpoints implemented
1.2. Instruction selection: the most optimized instructions must be selected depending on the code.
e.g.
a = 0; => iconst_0 instead of ldc 0 or sipush 0
a = 14; => bipush 14 instead of ldc 14 or ...
i = i + 1; => convert to iinc 3 (where 3 is the local variable i) instead of load->iconst->istore
i < 0 => use 'load i => if_lt' instead of 'load i=>iconst_0=>if_icmpeq'
NOTE1: this is a simple instruction selection! you don't need to use any specific algorithm for the selection (e.g. no need for maximal munch!). This is as simple as the example above: iconst, bipush, sipush, ldc to load a constant, iinc to replace the i=i+1, if_lt when operation is done with value 0.
NOTE2: this topic is mentioned in the project description as follows: "We expect that by default (i.e., without the option “–o”), the compiler generates JVM code with lower cost instructions in the cases of: iload, istore, astore, aload, loading constants to the stack, use of iinc, etc." (page 7).