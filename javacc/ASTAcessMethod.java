/* Generated By:JJTree: Do not edit this line. ASTAcessMethod.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.*;

public
class ASTAcessMethod extends SimpleNode {
  String ast_identifier;
  String ast_method;

  String returnType = null;
  String leftClass = null;
  String leftType = null;

  public ASTAcessMethod(int id) {
    super(id);
  }

  public ASTAcessMethod(Compiler p, int id) {
    super(p, id);
  }

  @Override
  public int process(String className) {
    // ver o irmao da esquerda se é ASTObject ou ASTIdentifier
    SimpleNode bro = (SimpleNode)(((SimpleNode)this.jjtGetParent()).children[0]);

    if (this.children != null)
    ((SimpleNode)this.children[0]).process(className);

    List<String> argsType = new ArrayList<>();
     
    if(this.children != null && ((SimpleNode)this.children[0]).children != null) {
      for (int j = 0; j < ((SimpleNode)this.children[0]).children.length; j++) {
        ((SimpleNode)((SimpleNode)(this.children[0])).children[j]).process(className);
        argsType.add(((SimpleNode)((SimpleNode)(this.children[0])).children[j]).getType());
      }
    }

    String id_method_table;

    if(bro instanceof ASTObject) {

      leftType = "ASTObject";

      bro.process(className);

      System.out.println("ASTOBJECT " + ast_identifier + " : " + ast_method);

      // Symbol symbol = getSymbolFromTable(ast_identifier);

      id_method_table = SimpleNode.createId(ast_identifier, ast_method, argsType);

      Symbol method = getSymbolFromTable(id_method_table);

      if (method == null){
        
        Symbol parentClass = getSymbolFromTable(className);

        if (parentClass == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);

        if (!(parentClass instanceof SymbolClass)){
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        if (((SymbolClass)parentClass).ext == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
          
          
        id_method_table = SimpleNode.createId(((SymbolClass)parentClass).ext.identifier, ast_method, argsType);

        method = getSymbolFromTable(id_method_table);

        if (method == null)
          throw new RuntimeException(ast_method + " not declared.");

        SymbolMethod symbolMethod = (SymbolMethod)method;

        if (!((SymbolClass)parentClass).ext.identifier.equals(symbolMethod.className)) {
          throw new RuntimeException("Object " + ast_identifier + "(" + ast_identifier + ")" + " doesn't have " + ast_method + " method."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        returnType = symbolMethod.type;
        leftClass = ((SymbolClass)parentClass).ext.identifier;

      } else {

        if (!(method instanceof SymbolMethod)){
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        SymbolMethod thisSymbolMethod = (SymbolMethod)method;

        if(!ast_identifier.equals(thisSymbolMethod.className)) {
          throw new RuntimeException(ast_method + " method doesn't return a " + thisSymbolMethod.className + " object. Returns " + ast_identifier+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        returnType = thisSymbolMethod.type;
        leftClass = ast_identifier;
      }


      SymbolMethod symbolMethod = (SymbolMethod) method;

      if (!ast_identifier.equals(symbolMethod.className)) {
        throw new RuntimeException("Object " + ast_identifier + " doesn't have " + ast_method + " method."+ "\nLine: " + this.line + "; Col: " + this.column);
      }

    }
    else if(bro instanceof ASTIdentifier) {

      leftType = "ASTIdentifier"; 

      bro.process(className);
      
      System.out.println("ASTIDENTIFIER " + ast_identifier + " : " + ast_method);
      Symbol symbol = getSymbolFromTable(ast_identifier);

      if (symbol == null) {
        throw new RuntimeException("Variable not declared: " + ((ASTIdentifier)bro).ast_value+ "\nLine: " + this.line + "; Col: " + this.column);
      }

      if (symbol instanceof SymbolVar){

        SymbolVar var = (SymbolVar) symbol;

        if (!var.isInitialized) {
          throw new RuntimeException("Variable not initialized."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        id_method_table = SimpleNode.createId(var.type, ast_method, argsType);

      } else if (symbol instanceof SymbolClass){

        SymbolClass var = (SymbolClass) symbol;

        id_method_table = SimpleNode.createId(var.identifier, ast_method, argsType);

      } else {
        throw new RuntimeException("Method doesnt belong to type"+ "\nLine: " + this.line + "; Col: " + this.column);
      }
      

      Symbol method = getSymbolFromTable(id_method_table);

      if (method == null){
        
        Symbol parentClass = getSymbolFromTable(className);

        if (parentClass == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);

        if (!(parentClass instanceof SymbolClass)){
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        if (((SymbolClass)parentClass).ext == null){
          System.out.println(id_method_table);
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }
          
          
        id_method_table = SimpleNode.createId(((SymbolClass)parentClass).ext.identifier, ast_method, argsType);

        method = getSymbolFromTable(id_method_table);

        if (method == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);

        SymbolMethod symbolMethod = (SymbolMethod)method;

        if (!((SymbolClass)parentClass).ext.identifier.equals(symbolMethod.className)) {
          throw new RuntimeException("Object " + ast_identifier + "(" + symbol.type + ")" + " doesn't have " + ast_method + " method."+ "\nLine: " + this.line + "; Col: " + this.column);
        }
        leftClass = ((SymbolClass)parentClass).ext.identifier;
        returnType = symbolMethod.type;

      } else {

        if (!(method instanceof SymbolMethod)){
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        SymbolMethod thisSymbolMethod = (SymbolMethod)method;

        if(!symbol.type.equals(thisSymbolMethod.className) && !symbol.identifier.equals(thisSymbolMethod.className)) {
          throw new RuntimeException(ast_method + " method doesn't return a " + thisSymbolMethod.className + " object. Returns " + ast_identifier+ "\nLine: " + this.line + "; Col: " + this.column);
        }
        leftClass = thisSymbolMethod.className;
        returnType = thisSymbolMethod.type;
      }

      // SymbolMethod symbolMethod = (SymbolMethod) method;

      // if (!symbol.type.equals(symbolMethod.className)) {
      //   throw new RuntimeException("Object " + ast_identifier + " doesn't have " + ast_method + " method.");
      // }

      // returnType = symbolMethod.type;

  

    } 
    else if(bro instanceof ASTAcessMethod) {

      leftType = "ASTAcessMethod";

      System.out.println("ASTACESSMETHOD " + ast_identifier + " : " + ast_method);

      id_method_table = SimpleNode.createId(bro.getType(), ast_method, argsType);
      
      // Symbol leftMethod = getSymbolFromTable(ast_identifier);
      Symbol method = getSymbolFromTable(id_method_table);

      if (method == null){
        
        Symbol parentClass = getSymbolFromTable(className);

        if (parentClass == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);

        if (!(parentClass instanceof SymbolClass)){
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        if (((SymbolClass)parentClass).ext == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
          
          
        id_method_table = SimpleNode.createId(((SymbolClass)parentClass).ext.identifier, ast_method, argsType);

        method = getSymbolFromTable(id_method_table);

        if (method == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);

        SymbolMethod thisSymbolMethod = (SymbolMethod)method;

        if(!((SymbolClass)parentClass).ext.identifier.equals(thisSymbolMethod.className))
          throw new RuntimeException(ast_method + " method doesn't return a " + thisSymbolMethod.className + " object. Returns " + ((SymbolClass)parentClass).ext.identifier+ "\nLine: " + this.line + "; Col: " + this.column);

        returnType = thisSymbolMethod.type;
        leftClass = ((SymbolClass)parentClass).ext.identifier;

      } else {

        if (!(method instanceof SymbolMethod)){
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        SymbolMethod thisSymbolMethod = (SymbolMethod)method;

        if(!ast_identifier.equals(thisSymbolMethod.className)) {
          throw new RuntimeException(ast_method + " method doesn't return a " + thisSymbolMethod.className + " object. Returns " + ast_identifier+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        returnType = thisSymbolMethod.type;
        leftClass = thisSymbolMethod.className;
      }
      
      

      // if(!ast_identifier.equals(thisSymbolMethod.className)) {
      //   if(!((SymbolClass)parentClass).ext.identifier.equals(thisSymbolMethod.className))
      //   throw new RuntimeException(ast_method + " method doesn't return a " + thisSymbolMethod.className + " object. Returns " + ast_identifier);
      // }   

      

      // if (thisSymbolMethod.arguments.size() != argsType.size()){
      //   throw new RuntimeException("Method args do not match in size(" + thisSymbolMethod.arguments.size() + ", " + argsType.size() +")");
      // }

      
      // for (int i = 0; i < thisSymbolMethod.arguments.size(); i++){
      //   if (!thisSymbolMethod.arguments.get(i).type.equals(argsType.get(i)))
      //     throw new RuntimeException("Method args do not match (" + thisSymbolMethod.arguments.get(i).type + ", " + argsType.get(i) +")");
      // }

    } 
    
    else if (bro instanceof ASTThis) {

      leftType = "ASTThis";

      bro.process(className);

      System.out.println("ASTOBJECT " + ast_identifier + " : " + ast_method);

      id_method_table = SimpleNode.createId(className, ast_method, argsType);

      Symbol method = getSymbolFromTable(id_method_table);

      if (method == null){
        
        Symbol parentClass = getSymbolFromTable(className);

        if (parentClass == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);

        if (!(parentClass instanceof SymbolClass)){
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        if (((SymbolClass)parentClass).ext == null){
          System.out.println(id_method_table);
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }
          
          
          
        id_method_table = SimpleNode.createId(((SymbolClass)parentClass).ext.identifier, ast_method, argsType);

        method = getSymbolFromTable(id_method_table);

        if (method == null)
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);

        SymbolMethod symbolMethod = (SymbolMethod)method;

        if (!((SymbolClass)parentClass).ext.identifier.equals(symbolMethod.className)) {
          throw new RuntimeException("Object " + className + "(" + className + ")" + " doesn't have " + ast_method + " method."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        returnType = symbolMethod.type;
        leftClass = ((SymbolClass)parentClass).ext.identifier;

      } else {

        if (!(method instanceof SymbolMethod)){
          throw new RuntimeException(ast_method + " not declared."+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        SymbolMethod thisSymbolMethod = (SymbolMethod)method;

        if(!className.equals(thisSymbolMethod.className)) {
          throw new RuntimeException(ast_method + " method doesn't return a " + thisSymbolMethod.className + " object. Returns " + className+ "\nLine: " + this.line + "; Col: " + this.column);
        }

        returnType = thisSymbolMethod.type;
        leftClass = thisSymbolMethod.className;
      }

      // SymbolMethod symbolMethod = (SymbolMethod) method;

      // if (!className.equals(symbolMethod.className)) {
      //   System.out.println(symbolMethod.className);
      //   throw new RuntimeException("Object " + className + " doesn't have " + ast_method + " method."+ "\nLine: " + this.line + "; Col: " + this.column);
      // }

      // returnType = className;


      // System.out.println("\nARGUMENTOS:" + argsType + "\n");

      // if (symbolMethod.arguments.size() != argsType.size()){
      //   throw new RuntimeException("Method args do not match in size(" + symbolMethod.arguments.size() + ", " + argsType.size() +")"+ "\nLine: " + this.line + "; Col: " + this.column);
      // }

      
      // for (int i = 0; i < symbolMethod.arguments.size(); i++){
      //   if (!symbolMethod.arguments.get(i).type.equals(argsType.get(i)))
      //     throw new RuntimeException("Method args do not match (" + symbolMethod.arguments.get(i).type + ", " + argsType.get(i) +")"+ "\nLine: " + this.line + "; Col: " + this.column);
      // }
      
    } else throw new RuntimeException("opa nao sei que dizer, és um burro"+ "\nLine: " + this.line + "; Col: " + this.column);

    return 1;
  }

  public String getType(){
    if (returnType == null)
      return "return type not initialized";
    return returnType;
  }

  public String generateCode(String className){
    String code = "";

    List<String> argsType = new ArrayList<>();
    
    if(this.children != null && ((SimpleNode)this.children[0]).children != null) {
      for (int j = 0; j < ((SimpleNode)this.children[0]).children.length; j++) {
        argsType.add(((SimpleNode)((SimpleNode)(this.children[0])).children[j]).getType());
      }
    }

    String id_method_table = SimpleNode.createId(leftClass, ast_method, argsType);
    Symbol method = getSymbolFromTable(id_method_table);

    // invocar
    if (((SymbolMethod)method).isStatic) {

    //   //por argumentos na stack
     if (this.children != null)
     for(int i = 0; i < this.children.length; i++) {
       System.out.println("HMMM2222");
       code += ((SimpleNode)this.children[i]).generateCode(className);
     }

     if(this.children != null && ((SimpleNode)this.children[0]).children != null) {
      System.out.println("DEC STACK: " + ((SimpleNode)this.children[0]).children.length);
      CodeGenerator.decStack(((SimpleNode)this.children[0]).children.length,this);
    }

      code += "invokestatic " + leftClass + "/" + ast_method + "(";
    } else {
      switch(leftType){
        case "ASTThis":
          code += "aload_0\n";
          CodeGenerator.incStack(this);
          System.out.println("HMMM ASTThis");
        break;
        case "ASTObject":
          code += "new " + ast_identifier + "\n";
          CodeGenerator.incStack(this);
          code += "dup\n";
          CodeGenerator.incStack(this);
          code += "invokespecial " + ast_identifier + "/<init>()V\n";
          CodeGenerator.decStack(1,this);
          System.out.println("HMMM ASTObject");
        break;
        case "ASTIdentifier":
        System.out.println("HMMM ASTIdentifier BEFIRE");
          Symbol symbol = getSymbolFromTable(ast_identifier);
          if(symbol.id_jasmin != -1) { // If not in global scope
            code += "aload " + symbol.id_jasmin + "\n";
            CodeGenerator.incStack(this);
          } else {
            code += "aload_0\n";
            CodeGenerator.incStack(this);
            code +=  "getfield " + className + "/" + ast_identifier + " " + SimpleNode.getTypeJasmin(symbol.type) + "\n";
          }
          System.out.println("HMMM ASTIdentifier");
        break;
        case "ASTAcessMethod":
          ASTAcessMethod a_node = null;
          SimpleNode father = (SimpleNode)this.jjtGetParent();
      
          for(int i = 1; i < father.children.length; i++){
            if (father.children[i].equals(this)){
              a_node = (ASTAcessMethod) father.children[i - 1];
              break;
            }
          }
          System.out.println("HMMM ACessMethod");
          code += a_node.generateCode(className);
        break;
        default:
        break;
      }

      //por argumentos na stack
     if (this.children != null)
      for(int i = 0; i < this.children.length; i++) {
        code += ((SimpleNode)this.children[i]).generateCode(className);
      }

     if(this.children != null && ((SimpleNode)this.children[0]).children != null) {
      System.out.println("DEC STACK: " + ((SimpleNode)this.children[0]).children.length);
      CodeGenerator.decStack(((SimpleNode)this.children[0]).children.length,this);
    }

      code += "invokevirtual " + leftClass + "/" + ast_method + "(";        
    }

    if(!returnType.equals("void")) 
        CodeGenerator.incStack(this);
        
    for (String arg : argsType) 
      code += SimpleNode.getTypeJasmin(arg); 
    code += ")" + SimpleNode.getTypeJasmin(returnType) + "\n";

    return code;
  }
}
/* JavaCC - OriginalChecksum=5a72632e1aaebf06ca4ffdc6eef531b9 (do not edit this line) */
